# useEffect

: 애플리케이션 내 컴포넌트의 여러 값들 활용해 동기적으로 부수 효과를 만듬
: `언제` 일어나는지보다 어떤 상태값과 함께 실행되는지가 중요

## useEffect는 어떻게 의존성 배열이 변경된 것을 알고 실행될까?

=> 의존성에 있는 값을 보면서 의존성의 값이 이전과 다른 게 하나라도 있으면 부수 효과를 실행

state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수

함수 컴포넌트는 매번 함수를 실행해 렌더링을 수행

값의 변화를 관찰?

- proxy
- 데이터 바인딩
- 옵저버

## 클린업 함수

- 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행된다.
- 클린업 함수가 있는 경우 클린업 함수 실행 => 콜백 실행

## 의존성 없는 useEffect와 useEffect 없이 사용하는 경우의 차이?

- 실행 시점
- useEffect는 클라이언트 사이드에서 실행되는 것을 보장해 줌
- 렌더링이 완료된 이후에 실행됨,
- 일반 함수 직접 실행은 렌더링 도중 발생 => 함수 컴포넌트의 반환을 지연시킴

## 의존성 배열에 부수효과를 만든 상태가 없이 사용?

의존성 배열을 넘기지 않은 채 콜백 함수 내부에서 특정 값을 사용 => 관찰해서 실행돼야 하는 값과는 별개로 작동한다는 뜻.
=> 부수 효과가 실행될 위치로 적절한지 체크할 것

## useEffect 잘 사용하기

### 1. 첫 번째 인수에 함수명 쓰기

useEffect 내부 콜백 함수의 역할을 파악하기 쉬워짐

```ts
useEffect(
  function logActiveUser() {
    logging(user);
  },
  [user]
);
```

### 2. 거대 useEffect 만들지 말것

- 적은 의존성 배열을 사용하는 여러 개의 useEffect로 분리

### 3. 불필요한 외부 함수 만들지 말 것

useEffect 외부에 함수를 선언하고 콜백함수에서 호출해 사용X

## useEffect의 인수로 비동기 함수를 지정할 수 없는 이유?

- useEffect의 경쟁 상태 때문
